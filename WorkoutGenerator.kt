package com.dietbyai.dietapp

import android.content.Context
import android.util.Log
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.platform.LocalContext
import androidx.navigation.NavController
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import io.ktor.client.*
import io.ktor.client.request.*
import io.ktor.client.statement.*
import io.ktor.client.engine.cio.*
import io.ktor.http.*
import kotlinx.coroutines.*
import kotlinx.serialization.*
import kotlinx.serialization.json.*
import okhttp3.*
import org.json.JSONObject
import io.ktor.client.request.setBody
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.ui.graphics.Color
import androidx.compose.material3.*
import androidx.compose.ui.Alignment
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.ui.draw.clip
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import com.google.gson.Gson
import android.media.MediaPlayer
import androidx.compose.foundation.clickable
import androidx.compose.runtime.remember
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.sp
import org.json.JSONArray
import org.json.JSONException


@Composable
fun DropdownSelector(
    options: List<String>,
    selected: String,
    preferenceKey: String,
    onSelect: (String) -> Unit
) {
    val context = LocalContext.current
    var expanded by remember { mutableStateOf(false) }
    val preferences = context.getSharedPreferences("user_prefs", Context.MODE_PRIVATE)

    Box(
        modifier = Modifier
            .fillMaxWidth()
            .background(Color.White, RoundedCornerShape(8.dp))
            .border(1.dp, Color.Gray, RoundedCornerShape(8.dp))
    ) {
        Button(
            onClick = { expanded = true },
            modifier = Modifier.fillMaxWidth(),
            colors = ButtonDefaults.buttonColors(containerColor = Color.White)
        ) {
            Text(selected.ifEmpty { "Wybierz opcjƒô" }, color = Color.Black)
        }

        DropdownMenu(
            expanded = expanded,
            onDismissRequest = { expanded = false }
        ) {
            options.forEach { option ->
                DropdownMenuItem(
                    text = { Text(option, color = Color.Black) },
                    onClick = {
                        preferences.edit().putString(preferenceKey, option).apply()
                        onSelect(option)
                        expanded = false
                    }
                )
            }
        }
    }
}

@Composable
fun DropdownMultiSelect(
    options: List<String>,
    selectedOptions: List<String>,
    preferenceKey: String, // üÜï Dodajemy klucz dla zapisania ustawie≈Ñ
    onSelectionChange: (List<String>) -> Unit
) {
    val context = LocalContext.current
    val preferences = context.getSharedPreferences("user_prefs", Context.MODE_PRIVATE)

    var expanded by remember { mutableStateOf(false) }
    val selectedText = if (selectedOptions.isEmpty()) "Wybierz opcje" else selectedOptions.joinToString(", ")

    Column {
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .background(Color.White, RoundedCornerShape(8.dp))
                .border(1.dp, Color.Gray, RoundedCornerShape(8.dp))
        ) {
            Button(
                onClick = { expanded = true },
                modifier = Modifier.fillMaxWidth(),
                colors = ButtonDefaults.buttonColors(containerColor = Color.White)
            ) {
                Text(selectedText, color = Color.Black)
            }

            DropdownMenu(expanded = expanded, onDismissRequest = { expanded = false }) {
                options.forEach { option ->
                    val isSelected = selectedOptions.contains(option)
                    DropdownMenuItem(
                        text = {
                            Row(verticalAlignment = Alignment.CenterVertically) {
                                Checkbox(checked = isSelected, onCheckedChange = null)
                                Spacer(modifier = Modifier.width(8.dp))
                                Text(option)
                            }
                        },
                        onClick = {
                            val newSelection = if (isSelected) {
                                selectedOptions - option
                            } else {
                                selectedOptions + option
                            }
                            preferences.edit().putStringSet(preferenceKey, newSelection.toSet()).apply() // üÜï Zapis listy
                            onSelectionChange(newSelection)
                        }
                    )
                }
            }
        }
    }
}


@Composable
fun WorkoutScreen(navController: NavController, subscriptionStatus: MutableState<String>) {
    val context = LocalContext.current
    var isLoading by remember { mutableStateOf(false) }
    var progress by remember { mutableStateOf(0f) }
    val preferences = context.getSharedPreferences("workout_prefs", Context.MODE_PRIVATE)
    val storedJson = preferences.getString("saved_workout", null)
    Log.d("WorkoutPreferences", "Zapisany trening w SharedPreferences: $storedJson")

    var remainingTime by remember { mutableStateOf(getRemainingWorkoutCooldownTime(context)) }
    val canGenerateWorkout = remainingTime == 0L && subscriptionStatus.value == "Subskrypcja aktywna"

    /*
// üîÑ Uruchamiamy odliczanie co sekundƒô
    LaunchedEffect(remainingTime) {
        while (remainingTime > 0) {
            delay(1000)
            remainingTime = getRemainingWorkoutCooldownTime(context)
        }
    }
     */

    // ‚úÖ Resetowanie stanu po opuszczeniu ekranu
    DisposableEffect(Unit) {
        onDispose {
            isLoading = false
            progress = 0f
        }
    }


// üéØ Wczytywanie zapisanych warto≈õci z SharedPreferences
    var goal by remember {
        mutableStateOf(preferences.getString("goal", null) ?: "")
    }
    var level by remember {
        mutableStateOf(preferences.getString("level", null) ?: "")
    }
    var location by remember {
        mutableStateOf(preferences.getString("location", null) ?: "")
    }
    var duration by remember {
        mutableStateOf(preferences.getString("duration", null) ?: "")
    }
    var trainingType by remember {
        mutableStateOf(preferences.getString("trainingType", null) ?: "")
    }

// üéØ Obs≈Çuga list (partie miƒô≈õniowe, sprzƒôt) - zapisane jako Set<String>
    var muscleGroups by remember {
        mutableStateOf(preferences.getStringSet("muscleGroups", emptySet())?.toList() ?: listOf())
    }
    var equipment by remember {
        mutableStateOf(preferences.getStringSet("equipment", emptySet())?.toList() ?: listOf())
    }

    var intensity by remember {
        mutableStateOf(preferences.getString("intensity", null) ?: "")
    }
    var daysPerWeek by remember {
        mutableStateOf(preferences.getString("daysPerWeek", null) ?: "")
    }
    var trainingStyle by remember {
        mutableStateOf(preferences.getString("trainingStyle", null) ?: "")
    }
    var restTime by remember {
        mutableStateOf(preferences.getString("restTime", null) ?: "")
    }
    var recoveryMode by remember {
        mutableStateOf(preferences.getString("recoveryMode", null) ?: "")
    }
    var preferencesList by remember { mutableStateOf(emptyList<String>()) }

    val savedWorkoutPlan = preferences.getString("saved_workout", null)

    // ‚úÖ Dostosowanie sprzƒôtu do miejsca treningu
    val availableEquipment = if (location == "Dom") {
        listOf(
            "Brak sprzƒôtu",
            "Hantle",
            "Ta≈õmy oporowe",
            "Kettlebell",
            "DrƒÖ≈ºek",
            "Skakanka",
            "Rowerek stacjonarny",
            "Orbitrek",
            "Bie≈ºnia"
        )
    } else {
        listOf(
            "Hantle",
            "Sztanga",
            "Maszyny",
            "Kettlebell",
            "DrƒÖ≈ºek",
            "Pi≈Çka fitness",
            "Skakanka",
            "Rowerek stacjonarny",
            "Orbitrek",
            "Bie≈ºnia"
        )
    }



    if (isLoading) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center,
            modifier = Modifier.fillMaxSize()
                .padding(16.dp)
        ) {
            Text(
                text = "Generowanie treningu...",
                style = MaterialTheme.typography.bodyLarge,
            )
            Text(
                text = "To mo≈ºe potrwaƒá kilka minut.",
                style = MaterialTheme.typography.bodyLarge,
            )
            Text(
                text = "Prosimy o cierpliwo≈õƒá ‚ù§",
                style = MaterialTheme.typography.bodyLarge,
            )

            Spacer(modifier = Modifier.height(16.dp))

            CircularProgressIndicator(
                modifier = Modifier.size(50.dp),
                strokeWidth = 6.dp
            )
            Spacer(modifier = Modifier.height(16.dp))

            LinearProgressIndicator(
                progress = { progress.coerceIn(0f, 1f) },  // üÜï Dynamiczna aktualizacja progresu
                modifier = Modifier.fillMaxWidth().height(8.dp)
            )
            Spacer(modifier = Modifier.height(8.dp))

            Text(
                text = "${(progress * 100).toInt()}% uko≈Ñczono",
                style = MaterialTheme.typography.bodyLarge
            )

            Column(
                modifier = Modifier
                    .padding(16.dp)
                    .border(
                        2.dp,
                        MaterialTheme.colorScheme.primary,
                        RoundedCornerShape(8.dp)
                    )
                    .background(
                        MaterialTheme.colorScheme.surface,
                        RoundedCornerShape(8.dp)
                    )
                    .padding(16.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                // Logo
                Icon(
                    painter = painterResource(id = R.drawable.logo_512x512_dietbyai), // Wstaw odpowiedni zas√≥b loga
                    contentDescription = "Logo",
                    tint = Color.Unspecified,
                    modifier = Modifier.size(64.dp)
                )

                Spacer(modifier = Modifier.height(8.dp))

                // Tekst
                Text(
                    text = "Wy≈ÇƒÖczenie aplikacji lub naci≈õniƒôcie przycisku 'Panel g≈Ç√≥wny' przerwie generowanie treningu.",
                    color = Color.Black, // Czarna czcionka
                    style = MaterialTheme.typography.bodyLarge,
                    textAlign = TextAlign.Center
                )
            }

            Spacer(modifier = Modifier.height(16.dp))

            Button(onClick = { navController.navigate(Screen.Welcome.route) }) {
                Text("Panel g≈Ç√≥wny")
            }
        }
    } else {
        LazyColumn(
            modifier = Modifier
                .background(Color.White) // Bia≈Çe t≈Ço
                .fillMaxSize()
                .padding(16.dp),
        ) {
            item {
                Text(
                    "\uD83D\uDCAA Plan treningu",
                    style = MaterialTheme.typography.headlineSmall,
                    color = MaterialTheme.colorScheme.primary,
                    textAlign = TextAlign.Center, // Wy≈õrodkowanie tekstu
                    modifier = Modifier.fillMaxWidth() // RozciƒÖgniƒôcie na ca≈ÇƒÖ szeroko≈õƒá
                )
                Spacer(modifier = Modifier.height(8.dp))
            }


// üéØ Wyb√≥r celu treningowego
            item {
                Text(
                    "‚úî Wybierz sw√≥j cel treningowy:",
                    style = MaterialTheme.typography.bodyLarge,
                    modifier = Modifier.padding(bottom = 8.dp) // Dodaje dolny margines 8dp
                )
            }
            item {
                DropdownSelector(
                    listOf(
                        "Budowa masy miƒô≈õniowej",
                        "Redukcja tkanki t≈Çuszczowej",
                        "Poprawa kondycji"
                    ),
                    goal,
                    "goal"
                ) {
                    goal = it
                    preferences.edit().putString("goal", it).apply()
                }
            }

            item { Spacer(modifier = Modifier.height(16.dp)) }

// üéØ Poziom zaawansowania
            item {
                Text(
                    "‚úî Poziom zaawansowania:",
                    style = MaterialTheme.typography.bodyLarge,
                    modifier = Modifier.padding(bottom = 8.dp) // Dodaje dolny margines 8dp
                )
            }

            item {
                DropdownSelector(
                    listOf("PoczƒÖtkujƒÖcy", "≈öredniozaawansowany", "Zaawansowany"),
                    level,
                    "level"
                ) {
                    level = it
                    preferences.edit().putString("level", it).apply()
                }
            }

// üîπ Opis poziomu zaawansowania
            val levelDescription = when (level) {
                "PoczƒÖtkujƒÖcy" -> "Dla os√≥b, kt√≥re dopiero zaczynajƒÖ swojƒÖ przygodƒô z treningiem. Skupia siƒô na nauce techniki i budowie podstawowej si≈Çy."
                "≈öredniozaawansowany" -> "Dla os√≥b z do≈õwiadczeniem 6-12 miesiƒôcy, kt√≥re chcƒÖ zwiƒôkszyƒá obciƒÖ≈ºenia i progresowaƒá w treningu."
                "Zaawansowany" -> "Dla os√≥b trenujƒÖcych regularnie od d≈Çu≈ºszego czasu. Wymaga du≈ºej objƒôto≈õci treningowej i stosowania zaawansowanych technik."
                else -> "Wybierz poziom zaawansowania, aby zobaczyƒá wiƒôcej informacji."
            }

            item {
                Text(
                    text = levelDescription,
                    style = MaterialTheme.typography.bodySmall,
                    textAlign = TextAlign.Center,
                    color = Color.Black,
                    modifier = Modifier.padding(top = 8.dp)
                )
            }


            item { Spacer(modifier = Modifier.height(16.dp)) }

// üéØ Miejsce treningu
            item {
                Text(
                    "‚úî Miejsce treningu:",
                    style = MaterialTheme.typography.bodyLarge,
                    modifier = Modifier.padding(bottom = 8.dp) // Dodaje dolny margines 8dp
                )
            }
            item {
                DropdownSelector(
                    listOf("Dom", "Si≈Çownia"),
                    location,
                    "location"
                ) {
                    location = it
                    preferences.edit().putString("location", it).apply()
                }
            }

            item { Spacer(modifier = Modifier.height(16.dp)) }

// üéØ D≈Çugo≈õƒá treningu
            item {
                Text(
                    "‚úî D≈Çugo≈õƒá treningu:",
                    style = MaterialTheme.typography.bodyLarge,
                    modifier = Modifier.padding(bottom = 8.dp) // Dodaje dolny margines 8dp
                )
            }
            item {
                DropdownSelector(
                    listOf("20-30 minut", "30-45 minut", "45-60 minut", "60+ minut"),
                    duration,
                    "duration"
                ) {
                    duration = it
                    preferences.edit().putString("duration", it).apply()
                }
            }

            item { Spacer(modifier = Modifier.height(16.dp)) }

// üéØ Typ treningu
            item {
                Text(
                    "‚úî Typ treningu:",
                    style = MaterialTheme.typography.bodyLarge,
                    modifier = Modifier.padding(bottom = 8.dp) // Dodaje dolny margines 8dp
                )
            }

            item {
                DropdownSelector(
                    listOf("Si≈Çowy", "Cardio", "HIIT", "Crossfit"),
                    trainingType,
                    "trainingType"
                ) {
                    trainingType = it
                    preferences.edit().putString("trainingType", it).apply()
                }
            }

// üîπ Opis typu treningu
            val trainingTypeDescription = when (trainingType) {
                "Si≈Çowy" -> "Trening skupiony na budowie si≈Çy i masy miƒô≈õniowej, czƒôsto z u≈ºyciem ciƒô≈ºar√≥w."
                "Cardio" -> "ƒÜwiczenia zwiƒôkszajƒÖce wytrzyma≈Ço≈õƒá sercowo-naczyniowƒÖ, np. bieganie, rower, skakanka."
                "HIIT" -> "Wysoko intensywny trening interwa≈Çowy, ≈ÇƒÖczƒÖcy kr√≥tkie okresy wysi≈Çku i odpoczynku."
                "Crossfit" -> "Funkcjonalny trening o du≈ºej intensywno≈õci, ≈ÇƒÖczƒÖcy elementy si≈Çowe i kondycyjne."
                else -> "Wybierz typ treningu, aby zobaczyƒá wiƒôcej informacji."
            }

            item {
                Text(
                    text = trainingTypeDescription,
                    style = MaterialTheme.typography.bodySmall,
                    textAlign = TextAlign.Center,
                    color = Color.Black,
                    modifier = Modifier.padding(top = 8.dp)
                )
            }


            item { Spacer(modifier = Modifier.height(16.dp)) }

// üéØ Partie miƒô≈õniowe
            item {
                Text(
                    "‚úî Partie miƒô≈õniowe do treningu:",
                    style = MaterialTheme.typography.bodyLarge,
                    modifier = Modifier.padding(bottom = 8.dp) // Dodaje dolny margines 8dp
                )
            }
            item {
                DropdownMultiSelect(
                    listOf(
                        "Ca≈Çe cia≈Ço",
                        "Klatka piersiowa",
                        "Plecy",
                        "Nogi",
                        "Ramiona",
                        "Barki",
                        "Brzuch"
                    ),
                    muscleGroups,
                    "muscleGroups"
                ) {
                    muscleGroups = it
                    preferences.edit().putStringSet("muscleGroups", it.toSet()).apply()
                }
            }

            item { Spacer(modifier = Modifier.height(16.dp)) }

// üéØ Dostƒôpny sprzƒôt
            item {
                Text(
                    "‚úî Dostƒôpny sprzƒôt:",
                    style = MaterialTheme.typography.bodyLarge,
                    modifier = Modifier.padding(bottom = 8.dp) // Dodaje dolny margines 8dp
                )
            }
            item {
                DropdownMultiSelect(
                    listOf(
                        "Sztanga",
                        "Hantle",
                        "Kettlebell",
                        "Maszyny",
                        "Gumy oporowe",
                        "DrƒÖ≈ºek",
                        "Orbitrek",
                        "Rower stacjonarny",
                        "Bie≈ºnia"
                    ),
                    equipment,
                    "equipment"
                ) {
                    equipment = it
                    preferences.edit().putStringSet("equipment", it.toSet()).apply()
                }
            }

            item { Spacer(modifier = Modifier.height(16.dp)) }

// üéØ Intensywno≈õƒá treningu
            item {
                Text(
                    "‚úî Intensywno≈õƒá treningu:",
                    style = MaterialTheme.typography.bodyLarge,
                    modifier = Modifier.padding(bottom = 8.dp) // Dodaje dolny margines 8dp
                )
            }

            item {
                DropdownSelector(
                    listOf("Niska", "≈örednia", "Wysoka"),
                    intensity,
                    "intensity"
                ) {
                    intensity = it
                    preferences.edit().putString("intensity", it).apply()
                }
            }

// üîπ Opis intensywno≈õci treningu
            val intensityDescription = when (intensity) {
                "Niska" -> "Lekki trening o niskim tempie, idealny dla poczƒÖtkujƒÖcych i os√≥b w fazie regeneracji."
                "≈örednia" -> "Zr√≥wnowa≈ºony wysi≈Çek, odpowiedni dla wiƒôkszo≈õci os√≥b, ≈ÇƒÖczƒÖcy pracƒô nad si≈ÇƒÖ i kondycjƒÖ."
                "Wysoka" -> "Intensywny trening, czƒôsto zawierajƒÖcy interwa≈Çy i ƒáwiczenia o wysokiej dynamice."
                else -> "Wybierz intensywno≈õƒá treningu, aby zobaczyƒá wiƒôcej informacji."
            }

            item {
                Text(
                    text = intensityDescription,
                    style = MaterialTheme.typography.bodySmall,
                    textAlign = TextAlign.Center,
                    color = Color.Black,
                    modifier = Modifier.padding(top = 8.dp)
                )
            }


            item { Spacer(modifier = Modifier.height(16.dp)) }

// üéØ Liczba dni treningowych w tygodniu
            item {
                Text(
                    "‚úî Liczba dni treningowych w tygodniu:",
                    style = MaterialTheme.typography.bodyLarge,
                    modifier = Modifier.padding(bottom = 8.dp) // Dodaje dolny margines 8dp
                )
            }
            item {
                DropdownSelector(
                    listOf("2", "3", "4", "5", "6"),
                    daysPerWeek,
                    "daysPerWeek"
                ) {
                    daysPerWeek = it
                    preferences.edit().putString("daysPerWeek", it).apply()
                }
            }

            item { Spacer(modifier = Modifier.height(16.dp)) }

// üéØ Styl treningowy
            item {
                Text(
                    "‚úî Styl treningowy:",
                    style = MaterialTheme.typography.bodyLarge,
                    modifier = Modifier.padding(bottom = 8.dp) // Dodaje dolny margines 8dp
                )
            }

            item {
                DropdownSelector(
                    listOf("Trening FBW", "Split", "Push-Pull-Legs", "Bodyweight"),
                    trainingStyle,
                    "trainingStyle"
                ) {
                    trainingStyle = it
                    preferences.edit().putString("trainingStyle", it).apply()
                }
            }

// üîπ Kr√≥tki opis stylu treningowego
            val trainingStyleDescription = when (trainingStyle) {
                "Trening FBW" -> "Trening ca≈Çego cia≈Ça w ka≈ºdej sesji. Idealny dla poczƒÖtkujƒÖcych i tych, kt√≥rzy chcƒÖ efektywnego treningu przy mniejszej liczbie dni."
                "Split" -> "Podzia≈Ç treningu na partie miƒô≈õniowe (np. klatka + triceps, plecy + biceps). ≈öwietny dla ≈õredniozaawansowanych i zaawansowanych."
                "Push-Pull-Legs" -> "Trening podzielony na ruchy pchajƒÖce, przyciƒÖgajƒÖce i nogi. Dobry dla os√≥b chcƒÖcych optymalizowaƒá regeneracjƒô."
                "Bodyweight" -> "Trening z masƒÖ w≈Çasnego cia≈Ça. Nie wymaga sprzƒôtu, dobry dla os√≥b ƒáwiczƒÖcych w domu."
                else -> "Wybierz styl treningowy, aby zobaczyƒá wiƒôcej informacji."
            }

            item {
                Text(
                    text = trainingStyleDescription,
                    style = MaterialTheme.typography.bodySmall,
                    textAlign = TextAlign.Center,
                    color = Color.Black,
                    modifier = Modifier.padding(top = 8.dp)
                )
            }

            item { Spacer(modifier = Modifier.height(16.dp)) }

// üéØ Czas odpoczynku miƒôdzy seriami
            item {
                Text(
                    "‚úî Czas odpoczynku miƒôdzy seriami:",
                    style = MaterialTheme.typography.bodyLarge,
                    modifier = Modifier.padding(bottom = 8.dp) // Dodaje dolny margines 8dp
                )
            }
            item {
                Spacer(modifier = Modifier.height(8.dp))
                DropdownSelector(
                    listOf("30 sekund", "60 sekund", "90 sekund", "120 sekund"),
                    restTime,
                    "restTime"
                ) {
                    restTime = it
                    preferences.edit().putString("restTime", it).apply()
                }
            }

            item { Spacer(modifier = Modifier.height(16.dp)) }

// üéØ Tryb regeneracji
            item {
                Text(
                    "‚úî Tryb regeneracji:",
                    style = MaterialTheme.typography.bodyLarge,
                    modifier = Modifier.padding(bottom = 8.dp) // Dodaje dolny margines 8dp
                )
            }

            item {
                DropdownSelector(
                    listOf(
                        "Aktywna regeneracja",
                        "Pasywna regeneracja",
                        "Stretching",
                        "Mobilizacja"
                    ),
                    recoveryMode,
                    "recoveryMode"
                ) {
                    recoveryMode = it
                    preferences.edit().putString("recoveryMode", it).apply()
                }
            }

// üîπ Opis trybu regeneracji
            val recoveryDescription = when (recoveryMode) {
                "Aktywna regeneracja" -> "Lekkie ƒáwiczenia (np. spacer, p≈Çywanie) pomagajƒÖce w szybszej regeneracji miƒô≈õni."
                "Pasywna regeneracja" -> "Pe≈Çny odpoczynek bez aktywno≈õci fizycznej, pozwalajƒÖcy na regeneracjƒô organizmu."
                "Stretching" -> "RozciƒÖganie poprawiajƒÖce elastyczno≈õƒá miƒô≈õni i redukujƒÖce napiƒôcie po treningu."
                "Mobilizacja" -> "ƒÜwiczenia poprawiajƒÖce zakres ruchu i elastyczno≈õƒá staw√≥w, zapobiegajƒÖce kontuzjom."
                else -> "Wybierz tryb regeneracji, aby zobaczyƒá wiƒôcej informacji."
            }

            item {
                Text(
                    text = recoveryDescription,
                    style = MaterialTheme.typography.bodySmall,
                    textAlign = TextAlign.Center,
                    color = Color.Black,
                    modifier = Modifier.padding(top = 8.dp)
                )
            }

            item { Spacer(modifier = Modifier.height(24.dp)) }



            item {
                Column(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    // ‚úÖ Funkcja sprawdzajƒÖca, czy formularz jest poprawnie wype≈Çniony
                    val isFormValid = remember {
                        derivedStateOf {
                            goal.isNotEmpty() &&
                                    level.isNotEmpty() &&
                                    location.isNotEmpty() &&
                                    duration.isNotEmpty() &&
                                    trainingType.isNotEmpty() &&
                                    muscleGroups.isNotEmpty() &&
                                    equipment.isNotEmpty() &&
                                    intensity.isNotEmpty() &&
                                    daysPerWeek.isNotEmpty() &&
                                    trainingStyle.isNotEmpty() &&
                                    restTime.isNotEmpty() &&
                                    recoveryMode.isNotEmpty()
                        }
                    }

                    // ‚úÖ Komunikaty o brakujƒÖcych polach
                    var showErrors by remember { mutableStateOf(false) }

                    // üìù Tekst informacyjny nad przyciskiem
                    if (remainingTime > 0) {
                        val minutes = (remainingTime / 1000) / 60
                        val seconds = (remainingTime / 1000) % 60

                        Text(
                            text = "‚è≥ Nowy plan treningowy mo≈ºesz\nwygenerowaƒá za: ${minutes} min.",
                            textAlign = TextAlign.Center,
                            style = MaterialTheme.typography.bodyLarge,
                            modifier = Modifier.fillMaxWidth().padding(bottom = 8.dp)
                        )
                    }else{

                        Text(
                            text = "‚è≥ Plany treningowe mo≈ºesz\ngenerowaƒá co 30 min.",
                            textAlign = TextAlign.Center,
                            style = MaterialTheme.typography.bodyLarge,
                            modifier = Modifier.fillMaxWidth().padding(bottom = 8.dp)
                        )

                    }

                    Box(
                        modifier = Modifier.fillMaxWidth(),
                        contentAlignment = Alignment.Center
                    ) {
                        Button(
                            onClick = {
                                if (isFormValid.value) {
                                    if (remainingTime == 0L) {
                                        isLoading = true
                                        progress = 0f
                                        showErrors = false

                                        updateLastWorkoutGenerationTime(context) // üïí Zapisujemy czas generowania

                                        generateWorkout(
                                            goal, level, location, duration, trainingType,
                                            muscleGroups, equipment, intensity, daysPerWeek,
                                            trainingStyle, preferencesList, restTime, recoveryMode,
                                            context, updateProgress = { newProgress -> progress = newProgress }
                                        ) { response ->
                                            if (!response.isNullOrBlank()) {
                                                preferences.edit().putString("saved_workout", response).apply()
                                            }
                                            isLoading = false
                                            navController.navigate("workout_result")
                                        }
                                    }
                                } else {
                                    showErrors = true // ‚ùå Pokazujemy komunikat o b≈Çƒôdach
                                }
                            },
                            enabled = canGenerateWorkout,
                            modifier = Modifier.wrapContentWidth(Alignment.CenterHorizontally),
                            colors = ButtonDefaults.buttonColors(
                                containerColor = if (canGenerateWorkout) Color(0xFF007BFF) else Color.Gray,
                                contentColor = Color.White
                            )
                        ) {

                            LaunchedEffect(remainingTime) {
                                while (remainingTime > 0) {
                                    delay(10000)
                                    remainingTime = getRemainingWorkoutCooldownTime(context)
                                }
                            }
                            Text(
                                when {
                                    subscriptionStatus.value != "Subskrypcja aktywna" -> "‚ö° Generuj plan treningowy"
                                    remainingTime > 0 -> "‚è≥ Poczekaj..."
                                    else -> "‚ö° Generuj plan treningowy"
                                }
                            )
                        }
                    }

                    // üî¥ Komunikat o brakujƒÖcych polach, je≈õli formularz jest niekompletny
                    if (showErrors) {
                        Text(
                            text = "‚ùå Proszƒô uzupe≈Çniƒá wszystkie pola!",
                            color = Color.Red,
                            textAlign = TextAlign.Center,
                            style = MaterialTheme.typography.bodyLarge,
                            maxLines = 1,
                            overflow = TextOverflow.Ellipsis,
                            modifier = Modifier.fillMaxWidth().padding(horizontal = 16.dp)
                        )
                    }
                }
            }

            item {
                Box(
                    modifier = Modifier.fillMaxWidth(),
                    contentAlignment = Alignment.Center
                ) {
                    // Przycisk dla u≈ºytkownik√≥w bez subskrypcji
                    if (subscriptionStatus.value != "Subskrypcja aktywna") {
                        Column(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(16.dp), // Dodajemy padding dla estetyki
                            horizontalAlignment = Alignment.CenterHorizontally // Wy≈õrodkowanie w pionie
                        ) {
                            Spacer(modifier = Modifier.height(16.dp))

                            // Informacja o subskrypcji
                            Text(
                                "\uD83D\uDEAB Generowanie treningu dostƒôpne\nwy≈ÇƒÖcznie dla subskrybent√≥w",
                                color = Color.Black,
                                style = MaterialTheme.typography.bodyLarge,
                                textAlign = TextAlign.Center, // Wy≈õrodkowanie tekstu
                                modifier = Modifier.fillMaxWidth()
                            )

                            Spacer(modifier = Modifier.height(16.dp))

                            // Przycisk subskrypcji
                            Button(
                                onClick = { navController.navigate(Screen.Subscription.route) },
                                colors = ButtonDefaults.buttonColors(
                                    containerColor = Color(0xFFFFD700), // Z≈Çoty kolor t≈Ça przycisku
                                    contentColor = Color.Black         // Czarny kolor tekstu dla kontrastu
                                ),
                                modifier = Modifier
                                   // .fillMaxWidth(0.8f) // Przycisk zajmuje 80% szeroko≈õci
                                    .padding(8.dp)
                            ) {
                                Text(
                                    text = "üõí Kup subskrypcjƒô",
                                    style = MaterialTheme.typography.bodyLarge
                                )
                            }

                          //  Spacer(modifier = Modifier.height(8.dp))

                            Text(
                                "\uD83D\uDD25 Skorzystaj z promocji",
                                color = Color.Red,
                                style = MaterialTheme.typography.bodyLarge,
                                textAlign = TextAlign.Center,
                                modifier = Modifier.fillMaxWidth()
                            )
                        }
                    }
                }
            }

            item{

                Row(
                    horizontalArrangement = Arrangement.SpaceEvenly,
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 16.dp)
                ) {
                    Text(
                        text = "Wstecz",
                        modifier = Modifier.clickable { navController.popBackStack() },
                        color = MaterialTheme.colorScheme.primary,
                        style = MaterialTheme.typography.labelLarge.copy(fontSize = 15.sp)
                    )
                    Text(
                        text = "Panel g≈Ç√≥wny",
                        modifier = Modifier.clickable { navController.navigate(Screen.Welcome.route) },
                        color = MaterialTheme.colorScheme.primary,
                        style = MaterialTheme.typography.labelLarge.copy(fontSize = 15.sp)
                    )
                }
            }

        }
    }
}

@Composable
fun WorkoutResultScreen(navController: NavController) {
    val context = LocalContext.current
    val preferences = context.getSharedPreferences("workout_prefs", Context.MODE_PRIVATE)

    // üõë Pobranie zapisanej diety i sprawdzenie, czy JSON jest poprawny
    val workoutPlanJson = preferences.getString("saved_workout", null)
    Log.d("WorkoutLoad", "Za≈Çadowano plan: $workoutPlanJson") // üõë Sprawdzenie, co faktycznie ≈Çaduje ekran
    val workoutPlan = if (!workoutPlanJson.isNullOrBlank()) {
        parseWorkoutResponse(workoutPlanJson)
    } else {
        emptyList()
    }

    Log.d("WorkoutLoad", "Plan po parsowaniu: ${workoutPlan.size} dni") // üõë Sprawdzenie, czy lista nie jest pusta

    val completionPercentage = remember { mutableStateOf(0f) }

    // üü¢ Obliczamy progres w tle
    LaunchedEffect(workoutPlan) {
        completionPercentage.value = getWorkoutCompletionPercentage(context, workoutPlan)
    }

    // üèÜ Je≈õli u≈ºytkownik uko≈Ñczy≈Ç 100% planu ‚Üí przej≈õcie na ekran gratulacji
    LaunchedEffect(completionPercentage.value) {
        if (completionPercentage.value >= 1.0f) {
            navController.navigate("congratulations_screen")
        }
    }

    Scaffold(
        modifier = Modifier
            .background(Color.White) // Bia≈Çe t≈Ço
            .fillMaxSize(),

        bottomBar = {
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(bottom = 16.dp),
                contentAlignment = Alignment.Center
            ) {
                Button(
                    onClick = { navController.navigate(Screen.Welcome.route) },
                    modifier = Modifier.width(200.dp),
                    colors = ButtonDefaults.buttonColors(containerColor = Color(0xFF007BFF))
                ) {
                    Text("Panel g≈Ç√≥wny")
                }
            }
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .background(Color.White) // Bia≈Çe t≈Ço
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            if (workoutPlan.isEmpty()) {
                // üü¢ Je≈õli brak planu, poka≈º komunikat i przycisk do wygenerowania nowego
                Text(
                    text = "Nie masz jeszcze ≈ºadnego planu treningu.\nJe≈õli wystƒÖpi≈Ç b≈ÇƒÖd lub przerwa≈Ço po≈ÇƒÖczenie\nsp√≥rbuj wygnerowaƒá nowy plan treningowy",
                    style = MaterialTheme.typography.bodyLarge,
                    textAlign = TextAlign.Center,
                    color = Color.Gray
                )

                Spacer(modifier = Modifier.height(16.dp))

                Button(
                    onClick = { navController.navigate("workout") },
                    colors = ButtonDefaults.buttonColors(containerColor = Color(0xFFFF9800))
                ) {
                    Text("‚ö° Generuj nowy plan")
                }
            } else {
                // üü¢ Pasek postƒôpu treningu
                Text(
                    text = "Postƒôp treningu: ${(completionPercentage.value * 100).toInt()}%",
                    style = MaterialTheme.typography.bodyLarge,
                    fontWeight = FontWeight.Bold,
                    modifier = Modifier.padding(bottom = 8.dp)
                )

                LinearProgressIndicator(
                    progress = completionPercentage.value,
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(10.dp)
                        .clip(RoundedCornerShape(5.dp)),
                    color = Color(0xFF1B5E20) // Ciemnozielony pasek postƒôpu
                )

                Spacer(modifier = Modifier.height(16.dp))

                LazyColumn(
                    modifier = Modifier.fillMaxSize()
                ) {
                    item {
                        Text(
                            "\uD83D\uDCAA Plan treningu",
                            style = MaterialTheme.typography.headlineSmall,
                            color = MaterialTheme.colorScheme.primary,
                            textAlign = TextAlign.Center,
                            modifier = Modifier.fillMaxWidth()
                        )
                    }

                    workoutPlan.forEach { day ->
                        item {
                            val completed = remember { mutableStateOf(isWorkoutCompleted(context, day.day)) }

                            Column(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .padding(8.dp),
                                horizontalAlignment = Alignment.CenterHorizontally
                            ) {
                                Text(
                                    text = day.day,
                                    style = MaterialTheme.typography.headlineSmall,
                                    textAlign = TextAlign.Center,
                                    modifier = Modifier.fillMaxWidth()
                                )

                                if (completed.value) {
                                    Text(
                                        text = "‚úÖ Uko≈Ñczony",
                                        style = MaterialTheme.typography.bodyLarge,
                                        color = Color(0xFF1B5E20),
                                        textAlign = TextAlign.Center
                                    )

                                    Spacer(modifier = Modifier.height(8.dp))

                                    Button(
                                        onClick = {
                                            removeWorkoutProgress(context, day.day)
                                            completed.value = false
                                            completionPercentage.value = getWorkoutCompletionPercentage(context, workoutPlan)
                                        },
                                        colors = ButtonDefaults.buttonColors(containerColor = Color.Red)
                                    ) {
                                        Text("‚Ü© Cofnij uko≈Ñczenie")
                                    }
                                } else {
                                    Button(
                                        onClick = {
                                            saveWorkoutProgress(context, day.day)
                                            completed.value = true
                                            completionPercentage.value = getWorkoutCompletionPercentage(context, workoutPlan)
                                        }
                                    ) {
                                        Text("‚úÖ Oznacz jako uko≈Ñczony")
                                    }
                                }

// üü¢ Wy≈õwietlanie ƒáwicze≈Ñ
                                day.exercises.forEach { exercise ->
                                    Card(
                                        modifier = Modifier
                                            .background(Color.White) // Bia≈Çe t≈Ço
                                            .fillMaxWidth()
                                            .padding(4.dp),
                                        shape = RoundedCornerShape(8.dp),
                                        elevation = CardDefaults.elevatedCardElevation(2.dp),
                                    ) {
                                        Column(
                                            modifier = Modifier
                                                .background(Color.White) // Bia≈Çe t≈Ço
                                                .fillMaxWidth()
                                                .padding(8.dp),
                                            horizontalAlignment = Alignment.CenterHorizontally
                                        ) {
                                            Text(
                                                text = exercise.name,
                                                style = MaterialTheme.typography.bodyLarge,
                                                textAlign = TextAlign.Center,
                                                modifier = Modifier.fillMaxWidth()
                                            )

                                            Text(
                                                text = "Serie: ${exercise.sets}",
                                                style = MaterialTheme.typography.bodyMedium,
                                                textAlign = TextAlign.Center,
                                                modifier = Modifier.fillMaxWidth()
                                            )

                                            Text(
                                                text = exercise.description,
                                                style = MaterialTheme.typography.bodySmall,
                                                textAlign = TextAlign.Center,
                                                modifier = Modifier.fillMaxWidth()
                                            )

                                            Spacer(modifier = Modifier.height(8.dp))

                                            // üü¢ Opis "Jak wykonywaƒá"
                                            val detailedText = exercise.detailedDescription
                                                ?: "Brak szczeg√≥≈Çowego opisu"

                                            Text(
                                                text = "Jak wykonywaƒá?",
                                                style = MaterialTheme.typography.bodyMedium,
                                                fontWeight = FontWeight.Bold,
                                                textAlign = TextAlign.Center,
                                                modifier = Modifier.fillMaxWidth()
                                            )

                                            Text(
                                                text = detailedText,
                                                style = MaterialTheme.typography.bodySmall,
                                                textAlign = TextAlign.Center,
                                                modifier = Modifier.fillMaxWidth()
                                            )

                                            Spacer(modifier = Modifier.height(8.dp))

                                            // üü¢ Timer odpoczynku
                                            if (exercise.restTime > 0){
                                                Text(
                                                    text = "Sko≈Ñczy≈Çe≈õ serie?",
                                                    style = MaterialTheme.typography.bodyMedium,
                                                    fontWeight = FontWeight.Bold,
                                                    textAlign = TextAlign.Center,
                                                    modifier = Modifier.fillMaxWidth()
                                                )
                                                RestTimer(restTime = exercise.restTime) {
                                                    // Mo≈ºesz dodaƒá tu powiadomienie lub d≈∫wiƒôk
                                                }
                                            }

                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

// ‚úÖ Generowanie planu treningowego
fun generateWorkout(
    goal: String,
    level: String,
    location: String,
    duration: String,
    trainingType: String,
    muscleGroups: List<String>,
    equipment: List<String>,
    intensity: String,
    daysPerWeek: String,
    trainingStyle: String,
    preferences: List<String>,
    restTime: String,
    recoveryMode: String,
    context: Context,
    updateProgress: (Float) -> Unit,  // üÜï Dodajemy callback do aktualizacji progresu
    callback: (String) -> Unit
) {
    val client = HttpClient(CIO) {
        engine {
            requestTimeout = 120_000
        }
    }

    CoroutineScope(Dispatchers.IO).launch {
        try {

            val startTime = System.currentTimeMillis() // ‚è≥ Start licznika czasu
            val estimatedTime = 30_000L // ‚è≥ Zak≈Çadany czas generacji (30 sekund)

            // üîÑ Aktualizacja paska postƒôpu co 500ms
            launch {
                while (true) {
                    val elapsedTime = System.currentTimeMillis() - startTime
                    val progress = (elapsedTime.toFloat() / estimatedTime).coerceIn(0f, 1f)
                    updateProgress(progress)
                    if (progress >= 1f) break
                    delay(500) // üîÑ Od≈õwie≈ºanie co 500ms
                }
            }

            val requestData = mapOf(
                "model" to "gpt-4-turbo",
                "messages" to listOf(
                    mapOf("role" to "system", "content" to "Jeste≈õ trenerem personalnym. Generuj plany treningowe w formacie JSON, bez ```json na poczƒÖtku."),
                    mapOf("role" to "user", "content" to """
    Stw√≥rz plan treningowy dla u≈ºytkownika:
    - Cel: $goal
    - Poziom zaawansowania: $level
    - Miejsce treningu: $location
    - Czas treningu: $duration
    - Rodzaj treningu: $trainingType
    - Partie miƒô≈õniowe: ${muscleGroups.joinToString(", ")}
    - Dostƒôpny sprzƒôt: ${equipment.joinToString(", ")}
    - Intensywno≈õƒá: $intensity
    - Liczba dni w tygodniu: $daysPerWeek
    - Styl treningu: $trainingStyle
    - Czas odpoczynku miƒôdzy seriami: $restTime
    - Tryb regeneracji: $recoveryMode

    **Wynik zwr√≥ƒá jako JSON dok≈Çadnie w tym formacie:** 
    {
        "days": [
            {
                "day": "Dzie≈Ñ 1",
                "exercises": [
                    {
                        "name": "Przysiady",
                        "sets": "4x10",
                        "description": "ƒÜwiczenie anga≈ºujƒÖce nogi i po≈õladki.",
                        "detailedDescription": "Przysiady wykonuje siƒô stojƒÖc w lekkim rozkroku...",
                        "restTime": 45
                    }
                ]
            }
        ]
    }
    Pisz w jƒôzyku u≈ºytkownika przed wszystkim nazwy ƒáwicze≈Ñ.
    Nie zwracaj samej tablicy, zawsze zwracaj pe≈Çny obiekt JSON z kluczem "days".
""".trimIndent())

                ),
                "temperature" to 0.7
            )

            val requestBody = Gson().toJson(requestData)
            Log.d("WorkoutAPI", "Wysy≈Çany JSON: $requestBody")

            val response: HttpResponse = client.post("https://dietbyai.com/proxy.php") {
                headers {
                    append("X-API-KEY", "my-secret-key-82756287bdygfoetnl1000000")
                    append(HttpHeaders.ContentType, "application/json")
                }
                setBody(requestBody)
            }


            val responseBody = response.bodyAsText()
            Log.d("WorkoutAPI", "Odpowied≈∫ API: $responseBody")

            if (!responseBody.startsWith("{") && !responseBody.startsWith("[")) {
                withContext(Dispatchers.Main) {
                    callback("‚ùå B≈ÇƒÖd API: Niepoprawna odpowied≈∫.")
                    updateProgress(0f) // Reset progresu
                }
                return@launch
            }


            val jsonResponse = JSONObject(responseBody)

            if (!jsonResponse.has("choices")) {
                withContext(Dispatchers.Main) {
                    callback("‚ùå B≈ÇƒÖd API: Brak danych 'choices'. Odpowied≈∫: $responseBody")
                }
                return@launch
            }

            val rawContent = jsonResponse.getJSONArray("choices")
                .getJSONObject(0)
                .getJSONObject("message")
                .getString("content")

            // ‚úÖ Usuwamy ```json na poczƒÖtku i ``` na ko≈Ñcu, je≈õli sƒÖ
            val cleanedJson = rawContent.replace("```json", "").replace("```", "").trim()

            // ‚úÖ Sprawdzamy, czy JSON zaczyna siƒô od '[' (czy jest listƒÖ)
            val workoutDays = if (cleanedJson.startsWith("[")) {
                Gson().fromJson(cleanedJson, Array<WorkoutDay>::class.java).toList()
            } else {
                Gson().fromJson(cleanedJson, WorkoutResponse::class.java).days
            }

            val updatedJson = Gson().toJson(workoutDays)


            withContext(Dispatchers.Main) {
                callback(updatedJson)
                updateProgress(1f) // üÜï Postƒôp: 100% - zako≈Ñczono
            }
        } catch (e: Exception) {
            Log.e("WorkoutAPI", "B≈ÇƒÖd: ${e.message}")
            withContext(Dispatchers.Main) {
                callback("‚ùå B≈ÇƒÖd: ${e.message}")
                updateProgress(0f) // Reset progresu
            }
        }
    }
}

fun parseWorkoutResponse(json: String): List<WorkoutDay> {
    Log.d("WorkoutParser", "Parsujemy JSON: $json") // üõë Sprawdzamy, co jest w JSON

    val workoutDays = mutableListOf<WorkoutDay>()

    try {
        if (json.trim().startsWith("[")) {
            // üü¢ JSON jest tablicƒÖ, konwertujemy na JSONArray
            val daysArray = JSONArray(json)

            for (i in 0 until daysArray.length()) {
                val dayObject = daysArray.getJSONObject(i)
                val exercisesArray = dayObject.optJSONArray("exercises") ?: JSONArray()
                val exercises = mutableListOf<Exercise>()

                for (j in 0 until exercisesArray.length()) {
                    val exerciseObject = exercisesArray.getJSONObject(j)

                    val exercise = Exercise(
                        name = exerciseObject.optString("name", "Brak nazwy"),
                        sets = exerciseObject.optString("sets", "0x0"),
                        description = exerciseObject.optString("description", "Brak opisu"),
                        detailedDescription = exerciseObject.optString("detailedDescription", "Brak opisu"),
                        restTime = exerciseObject.optInt("restTime", 60), // üü¢ Je≈õli brak, ustaw 60s
                        difficultyLevel = exerciseObject.optString("difficultyLevel", "Brak poziomu"),
                        image = exerciseObject.optString("image", "")
                    )
                    exercises.add(exercise)
                }

                val workoutDay = WorkoutDay(dayObject.optString("day", "Brak dnia"), exercises)
                workoutDays.add(workoutDay)
            }
        } else if (json.trim().startsWith("{")) {
            // üü¢ JSON jest obiektem, pobieramy tablicƒô `days`
            val jsonObject = JSONObject(json)
            val daysArray = jsonObject.optJSONArray("days") ?: JSONArray()

            for (i in 0 until daysArray.length()) {
                val dayObject = daysArray.getJSONObject(i)
                val exercisesArray = dayObject.optJSONArray("exercises") ?: JSONArray()
                val exercises = mutableListOf<Exercise>()

                for (j in 0 until exercisesArray.length()) {
                    val exerciseObject = exercisesArray.getJSONObject(j)

                    val exercise = Exercise(
                        name = exerciseObject.optString("name", "Brak nazwy"),
                        sets = exerciseObject.optString("sets", "0x0"),
                        description = exerciseObject.optString("description", "Brak opisu"),
                        detailedDescription = exerciseObject.optString("detailedDescription", "Brak opisu"),
                        restTime = exerciseObject.optInt("restTime", 60),
                        difficultyLevel = exerciseObject.optString("difficultyLevel", "Brak poziomu"),
                        image = exerciseObject.optString("image", "")
                    )
                    exercises.add(exercise)
                }

                val workoutDay = WorkoutDay(dayObject.optString("day", "Brak dnia"), exercises)
                workoutDays.add(workoutDay)
            }
        } else {
            Log.e("WorkoutParser", "Niepoprawny format JSON")
        }
    } catch (e: JSONException) {
        Log.e("WorkoutParser", "B≈ÇƒÖd parsowania JSON: ${e.message}")
    }

    Log.d("WorkoutParser", "Zwrocono listƒô dni: ${workoutDays.size}") // üõë Sprawdzenie, czy zwraca dni
    return workoutDays
}


fun saveWorkoutProgress(context: Context, day: String) {
    val preferences = context.getSharedPreferences("workout_progress", Context.MODE_PRIVATE)
    val editor = preferences.edit()
    editor.putBoolean(day, true) // Zapisujemy, ≈ºe dany dzie≈Ñ treningowy zosta≈Ç uko≈Ñczony
    editor.apply()
}

fun isWorkoutCompleted(context: Context, day: String): Boolean {
    val preferences = context.getSharedPreferences("workout_progress", Context.MODE_PRIVATE)
    return preferences.getBoolean(day, false) // Pobiera status uko≈Ñczenia treningu
}

fun removeWorkoutProgress(context: Context, day: String) {
    val preferences = context.getSharedPreferences("workout_progress", Context.MODE_PRIVATE)
    val editor = preferences.edit()
    editor.remove(day) // Usuwamy informacjƒô o uko≈Ñczonym treningu
    editor.apply()
}

fun clearWorkoutProgress(context: Context) {
    val preferences = context.getSharedPreferences("workout_progress", Context.MODE_PRIVATE)
    val editor = preferences.edit()
    editor.clear() // Usuwa wszystkie zapisane uko≈Ñczone treningi
    editor.apply()
}

fun getWorkoutCompletionPercentage(context: Context, workoutPlan: List<WorkoutDay>): Float {
    val completedDays = workoutPlan.count { isWorkoutCompleted(context, it.day) }
    return if (workoutPlan.isNotEmpty()) {
        completedDays.toFloat() / workoutPlan.size.toFloat()
    } else {
        0f
    }
}

@Composable
fun RestTimer(restTime: Int, onFinish: () -> Unit) {
    var timeLeft by rememberSaveable { mutableStateOf(restTime) }
    var isRunning by rememberSaveable { mutableStateOf(false) }
    val context = LocalContext.current

    LaunchedEffect(key1 = isRunning, key2 = timeLeft) {
        if (isRunning) {
            while (timeLeft > 0) {
                delay(1000L)
                timeLeft--
            }
            isRunning = false
            val mediaPlayer = MediaPlayer.create(context, R.raw.alarm)
            mediaPlayer.start()
            onFinish()
        }
    }


    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        if (isRunning) {
            Text(
                text = "‚è≥ Odpoczynek: ${timeLeft}s",
                style = MaterialTheme.typography.bodyLarge,
                color = Color.Blue,
                textAlign = TextAlign.Center
            )
        } else {
            Button(
                onClick = {
                    isRunning = true
                    timeLeft = restTime // üü¢ Resetowanie czasu przed startem
                },
                colors = ButtonDefaults.buttonColors(
                    containerColor = Color(0xFF007BFF), // Piƒôkny odcie≈Ñ niebieskiego
                    contentColor = Color.White // Bia≈Çy tekst dla lepszej czytelno≈õci
                )
            ) {
                Text("\uD83D\uDD52 Rozpocznij odpoczynek (${restTime}s)")
            }

        }
    }
}

@Composable
fun CongratulationsScreen(navController: NavController) {
    val context = LocalContext.current

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        // üèÜ Nag≈Ç√≥wek gratulacyjny
        Text(
            text = "üéâ Gratulacje! üéâ",
            style = MaterialTheme.typography.headlineMedium,
            fontWeight = FontWeight.Bold,
            color = Color(0xFF1B5E20),
            textAlign = TextAlign.Center
        )

        Spacer(modifier = Modifier.height(16.dp))

        // üì¢ Informacja o zako≈Ñczeniu planu
        Text(
            text = "Uko≈Ñczy≈Çe≈õ ca≈Çy plan treningowy!\n Jeste≈õ niesamowity! üí™üî•",
            style = MaterialTheme.typography.bodyLarge,
            textAlign = TextAlign.Center
        )

        Spacer(modifier = Modifier.height(16.dp))

        // üìå Wskaz√≥wka dotyczƒÖca zmiany planu
        Text(
            text = "Aby uniknƒÖƒá stagnacji, dobrze jest zmieniaƒá trening co kilka tygodni. Mo≈ºesz kontynuowaƒá ten plan lub wygenerowaƒá nowy! üöÄ",
            style = MaterialTheme.typography.bodyMedium,
            textAlign = TextAlign.Center,
            color = Color.Gray,
            modifier = Modifier.padding(horizontal = 12.dp)
        )

        Spacer(modifier = Modifier.height(24.dp))

        // üîÑ Opcja restartu planu (zerowanie uko≈Ñczonych dni)
        Button(
            onClick = {
                clearWorkoutProgress(context) // Zerowanie uko≈Ñczonych dni
                navController.navigate("workout_result") // Powr√≥t do ekranu treningu
            },
            colors = ButtonDefaults.buttonColors(containerColor = Color(0xFF007BFF))
        ) {
            Text("üîÑ Rozpocznij ten sam\n plan od nowa", textAlign = TextAlign.Center)
        }

        Spacer(modifier = Modifier.height(12.dp))

        // ‚ö° Opcja wygenerowania nowego treningu
        Button(
            onClick = { navController.navigate("workout") },
            colors = ButtonDefaults.buttonColors(containerColor = Color(0xFFFF9800))
        ) {
            Text("‚ö° Generuj nowy plan\nna kolejny tydzie≈Ñ", textAlign = TextAlign.Center)
        }


        Spacer(modifier = Modifier.height(12.dp))

        // üè† Powr√≥t do menu g≈Ç√≥wnego
        Button(
            onClick = { navController.navigate(Screen.Welcome.route) },
        ) {
            Text("Panel g≈Ç√≥wny")
        }
    }
}

private val workoutCooldownMillis = 30 * 60 * 1000 // 30 minut
private const val LAST_WORKOUT_GENERATION_KEY = "LastWorkoutGenerationTime"

fun getRemainingWorkoutCooldownTime(context: Context): Long {
    val sharedPreferences = context.getSharedPreferences("workout_prefs", Context.MODE_PRIVATE)
    val lastWorkoutTime = sharedPreferences.getLong(LAST_WORKOUT_GENERATION_KEY, 0)
    val currentTime = System.currentTimeMillis()
    return (workoutCooldownMillis - (currentTime - lastWorkoutTime)).coerceAtLeast(0L)
}

fun updateLastWorkoutGenerationTime(context: Context) {
    val sharedPreferences = context.getSharedPreferences("workout_prefs", Context.MODE_PRIVATE)
    sharedPreferences.edit().putLong(LAST_WORKOUT_GENERATION_KEY, System.currentTimeMillis()).apply()
}

data class WorkoutResponse(
    val days: List<WorkoutDay>
)

data class WorkoutDay(
    val day: String,
    val exercises: List<Exercise>,
    var completed: Boolean = false // üÜï Dodajemy pole oznaczajƒÖce uko≈Ñczenie treningu
)

data class Exercise(
    val name: String,
    val sets: String,
    val description: String,
    val detailedDescription: String,
    val restTime: Int,
    val difficultyLevel: String,  // üÜï Pole, kt√≥re nie ma warto≈õci w JSON
    val image: String             // üÜï Pole, kt√≥re nie ma warto≈õci w JSON
)